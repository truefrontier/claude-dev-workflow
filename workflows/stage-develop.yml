name: Stage - Development

on:
  issues:
    types: [labeled]

jobs:
  development:
    if: >
      github.event.issue.state == 'open' &&
      (contains(github.event.issue.labels.*.name, 'needs:develop') ||
       contains(github.event.issue.labels.*.name, 'needs:develop-revision'))
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      actions: read
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history needed for branching

      - name: Setup stage context
        id: setup
        uses: actions/github-script@v7
        with:
          script: |
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });
            
            // Get all comments for comprehensive context
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              per_page: 100  // Increased to capture full conversation history
            });

            // Filter out deleted/empty comments
            const validComments = comments.data.filter(comment => 
              comment.body && 
              comment.body.trim() !== '' && 
              !comment.body.includes('[DELETED]')
            );

            // Check if this is initial development or revision
            const labels = issue.labels.map(label => label.name);
            const isRevision = labels.includes('needs:develop-revision');
            
            // Find the last human who mentioned the bot
            const lastHumanComment = validComments
              .reverse()
              .find(comment => 
                comment.user.type === 'User' && 
                comment.body.includes('@claude-dev-truefrontier')
              );
            
            const lastHumanUser = lastHumanComment ? lastHumanComment.user.login : null;
            core.setOutput('is_revision', isRevision.toString());
            core.setOutput('issue_details', JSON.stringify({
              ISSUE_NUMBER: context.issue.number,
              ASSIGNEES: issue.assignees || [],
              STATE: issue.state,
              CREATED_AT: issue.created_at,
              UPDATED_AT: issue.updated_at,
            }));
            core.setOutput('issue_description', issue.body || '');
            core.setOutput('recent_comments', JSON.stringify(validComments));
            core.setOutput('last_human_user', lastHumanUser);

      - name: Run Development Implementation
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          branch_prefix: "feature/issue-${{ github.event.issue.number }}-"
          base_branch: "main"
          use_sticky_comment: true
          allowed_bots: 'claude[bot]'
          claude_args: |
            --allowedTools "Bash,Edit,MultiEdit,Write,Glob,Grep,Read,Task,TodoWrite,WebFetch,WebSearch,mcp__github__get_issue,mcp__github__get_issue_comments,mcp__github__add_issue_comment,mcp__github__update_issue,mcp__github__create_branch,mcp__github__create_pull_request,mcp__github__push_files,mcp__github__create_or_update_file"
          prompt: |
            You are acting as a Senior Software Engineer implementing features based on specifications, technical plan, and task breakdown.

            <context>
              <issue_details>${{ steps.setup.outputs.issue_details }}</issue_details>
              <issue_description>${{ steps.setup.outputs.issue_description }}</issue_description>
              <recent_comments>${{ steps.setup.outputs.recent_comments }}</recent_comments>
              <is_revision>${{ steps.setup.outputs.is_revision }}</is_revision>
              <last_human_user>${{ steps.setup.outputs.last_human_user }}</last_human_user>
            </context>

            ## Your Task
            ${{ steps.setup.outputs.is_revision == 'true' && '
            This is a REVISION based on previous feedback. Review the recent comments for bug reports, test failures, or requested changes and address them.
            ' || '
            This is INITIAL DEVELOPMENT. Implement the complete feature based on approved specifications, technical plan, and task breakdown from previous comments.
            ' }}

            ## CRITICAL: Always Post Comment
            You MUST post a comment with your development summary, test results, and implementation details. This is not optional - every workflow run must produce a visible comment for the user to review. Your development progress and results will automatically be posted as a comment to the issue.

            ## Implementation Process

            ### 1. Review Previous Work (CRITICAL - Required Context)
            - Use `mcp__github__get_issue_comments` to retrieve all issue comments and review the complete conversation history
            - **MUST review the 2 required previous stage comments:**
              1. **Specification Stage Comment** - What needs to be built and why (user stories, requirements, acceptance criteria)
              2. **Comprehensive Plan Stage Comment** - How it will be built (architecture, technology choices, implementation strategy) AND detailed task breakdown (T001, T002, etc. with dependencies)
            - **EQUALLY IMPORTANT: Review all human feedback comments** - Human responses to each stage are critical for understanding:
              - What was approved/rejected in specifications
              - Plan modifications or concerns raised
              - Task adjustments or prioritization changes
              - Any additional requirements or constraints added by humans
            - **Integration Analysis:** Understand how human feedback shaped each stage's evolution
            - **READ THE PLAN COMPLETELY:** Before starting implementation, read the entire plan comment to understand the full context and approach

            ### 2. Execute Task Breakdown (Follow Approved Plan)
            - **Follow the exact task sequence** from the approved comprehensive plan comment (T001 → T002 → T003...)
            - **Respect human modifications** - If humans requested changes to the task order or priorities, follow their guidance
            - **Implement systematically:** Setup → Tests → Implementation → Integration → Validation
            - **Check dependencies:** Ensure prerequisite tasks are complete before starting dependent tasks
            - **Reference specific files and components** identified in the task breakdown
            - **Follow parallel task guidance** - Work on [P] marked tasks simultaneously when possible
            - **Reality Check:** If you encounter mismatches between the plan and actual codebase, STOP and think deeply about why:
              - Present the issue clearly: "Expected: [what the plan says] Found: [actual situation] Why this matters: [explanation]"
              - Adapt to what you find while following the plan's intent
              - Communicate any significant deviations clearly in your progress updates

            ### 3. Development Cycle
            1. **Implement Tasks**: Follow the prioritized task list step-by-step
            2. **Test as You Go**: Run tests after each significant change
            3. **Verify Integration**: Ensure changes work with existing code
            4. **Run Full Test Suite**: Execute all tests to verify nothing is broken
            5. **Refactor**: Improve code quality while keeping tests passing
            6. **Document**: Update documentation as needed

            ### 4. Verification and Progress Tracking (MANDATORY VERIFICATION)
            - **Batch verification at natural stopping points** - Don't let verification interrupt your flow
            - **MANDATORY: Verify all tool executions** - Never claim something was done without verification
            - **CRITICAL: After creating branches** - Run `git branch` to confirm branch exists and is active
            - **CRITICAL: After making commits** - Run `git log --oneline -5` to show recent commits actually exist
            - **CRITICAL: After file changes** - Use Read tool to verify changes were actually written to files
            - **CRITICAL: After running tests** - Show actual test output, never assume tests passed
            - Run complete test suite using the project's test commands
            - Fix any integration issues that arise
            - Ensure no existing functionality is broken
            - Verify all new functionality works end-to-end
            - Test edge cases and error conditions
            - **Update plan progress:** Mark completed tasks in your progress comments (reference the plan's checkboxes)
            - **Forward momentum:** Keep the end goal in mind and maintain progress toward the final deliverable

            ## Testing Requirements (Critical)
            - **ALL tests must pass** before considering implementation complete
            - Run the project's existing test suite to ensure compatibility
            - Create appropriate tests based on the project's testing framework:
              - Unit tests for business logic
              - Integration tests for external dependencies
              - End-to-end tests for user workflows
            - **Iterate until 100% of tests pass** - do not accept failing tests

            ## Code Quality Standards
            - Follow the project's existing coding standards and conventions
            - Maintain consistency with existing codebase patterns
            - Implement proper error handling and validation
            - Add appropriate comments and documentation
            - No placeholder code or TODOs in final implementation

            ## Git Workflow (AUTOMATIC OPERATIONS REQUIRED)
            **CRITICAL: You MUST perform these git operations automatically:**
            1. **Create feature branch**: `feature/issue-${{ github.event.issue.number }}-[description]`
            2. **Make atomic commits** with clear, descriptive messages
            3. **Push branch to origin** - Branch will be automatically created on remote
            4. **Verify all operations** - Show `git status`, `git log`, `git branch` outputs

            **Git Options (Choose best approach for your task):**

            **Option A - Bulk File Push (RECOMMENDED for multiple files):**
            - Use `mcp__github__push_files` to push all changes in one operation:
              - `branch`: `feature/issue-${{ github.event.issue.number }}-[description]`
              - `files`: Array of file objects with `path` and `content`
              - `message`: Descriptive commit message
              - `owner`: Repository owner from context
              - `repo`: Repository name from context

            **Option B - Single File Updates (RECOMMENDED for individual files):**
            - Use `mcp__github__create_or_update_file` for file-by-file commits:
              - `branch`: `feature/issue-${{ github.event.issue.number }}-[description]`
              - `path`: File path (e.g., "src/components/Component.vue")
              - `content`: File content as string
              - `message`: Commit message describing the change
              - `owner`: Repository owner from context
              - `repo`: Repository name from context
              - `sha`: Required for updates (get from file info first)

            **Option C - Manual Git Commands (fallback):**
            - `git checkout -b feature/issue-${{ github.event.issue.number }}-[description]`
            - `git add .` (or specific files)
            - `git commit -m "descriptive commit message"`
            - `git push origin feature/issue-${{ github.event.issue.number }}-[description]`
            - Follow conventional commit format when possible

            ## Required Actions (Execute in Order)
            
            **1. FIRST: Always Post Your Development Summary Comment Above**
            - You MUST explicitly call `mcp__github_comment__create_comment` or `mcp__github_comment__update_claude_comment` to post a comprehensive development summary
            - **Include Context Summary** - Briefly reference which specifications, technical plan elements, and task breakdown items you implemented
            - **Include Human Feedback Integration** - Note how you incorporated human feedback from previous stage reviews
            - Include a "What I'm Doing" section that explains your implementation approach
            - Post a comprehensive development summary including:
              - **MANDATORY PROOF SECTION:** Include verification commands and their outputs to prove work was actually completed
              - What was implemented (features, files changed, tests created)
              - All test results (must show 100% passing tests)
              - Branch name and commit details WITH VERIFICATION (`git branch`, `git log`, actual git status)
              - Any issues encountered and how they were resolved
              - Final implementation status and readiness for PR
              - **MUST INCLUDE: "Create a PR" link** using the format: `[Create a PR](https://github.com/${{ github.repository }}/compare/main...BRANCH_NAME)`
              - **NEVER claim branches/commits/changes exist without showing verification commands**
            - This happens automatically when you include the summary in your response
            - Do not proceed to step 2 until the comment is posted
            
            **2. THEN: Commit and Push Changes (MANDATORY)**
            After posting your development summary comment, you MUST commit and push your changes:
            - Create and checkout feature branch: `git checkout -b feature/issue-${{ github.event.issue.number }}-[description]`
            - Stage all changes: `git add .`
            - Commit with descriptive message: `git commit -m "implement [feature description]"`
            - Push branch to remote: `git push origin feature/issue-${{ github.event.issue.number }}-[description]`
            - Verify operations with: `git status`, `git log --oneline -3`, `git branch`

            **3. FINALLY: Update Workflow State**
            Only after successfully committing and pushing changes, execute these commands:

            Use `mcp__github__update_issue` with these parameters:
            - issue_number: ${{ github.event.issue.number }}
            - Remove "needs:develop" and "needs:develop-revision" from labels
            - Add "review:develop" to labels
            - Add assignee: "${{ steps.setup.outputs.last_human_user }}"

            First get current issue state with `mcp__github__get_issue`, then call `mcp__github__update_issue` with the updated labels list (keeping all non-workflow labels and adding review:develop).

            ## Success Criteria (WITH MANDATORY VERIFICATION)
            - All specified requirements are implemented and working
            - All project tests pass using the project's test suite (with verification output shown)
            - Code follows the project's best practices and conventions
            - No breaking changes to existing functionality
            - **Feature branch exists and is verified** (git branch output shown in comment)
            - **Commits exist and are verified** (git log output shown in comment)
            - **Changes pushed to remote repository** (git push successful and verified)
            - **File changes are verified** (Read tool used to confirm changes written)
            - **Test results are verified** (actual test output shown, not assumed)
            - Implementation is complete with no placeholder code
            - All tasks from the task breakdown are completed
            - **Development summary includes proof commands demonstrating all work was actually completed**

            **Remember: This is the final implementation stage. Everything must be production-ready and fully tested before completion.**