name: Stage - Plan

on:
  issues:
    types: [labeled]

jobs:
  plan:
    if: >
      github.event.issue.state == 'open' &&
      (contains(github.event.issue.labels.*.name, 'needs:plan') ||
       contains(github.event.issue.labels.*.name, 'needs:plan-revision'))
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      actions: read
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup stage context
        id: setup
        uses: actions/github-script@v7
        with:
          script: |
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            // Get recent comments for context
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              per_page: 100  // Increased to capture full conversation history
            });

            // Filter out deleted/empty comments and get non-bot comments
            const validComments = comments.data.filter(comment =>
              comment.body &&
              comment.body.trim() !== '' &&
              !comment.body.includes('[DELETED]')
            );

            // Check if this is initial plan or revision
            const labels = issue.labels.map(label => label.name);
            const isRevision = labels.includes('needs:plan-revision');

            // Find the last human who mentioned the bot (for assignment later)
            const lastHumanComment = validComments
              .reverse()
              .find(comment =>
                comment.user.type === 'User' &&
                comment.body.includes('@claude-dev-truefrontier')
              );

            const lastHumanUser = lastHumanComment ? lastHumanComment.user.login : null;
            core.setOutput('is_revision', isRevision.toString());
            core.setOutput('issue_details', JSON.stringify({
              ISSUE_NUMBER: context.issue.number,
              ASSIGNEES: issue.assignees || [],
              STATE: issue.state,
              CREATED_AT: issue.created_at,
              UPDATED_AT: issue.updated_at,
            }));
            core.setOutput('issue_description', issue.body || '');
            core.setOutput('recent_comments', JSON.stringify(validComments));
            core.setOutput('last_human_user', lastHumanUser);

      - name: Run Technical Planning and Task Breakdown
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          use_sticky_comment: true
          allowed_bots: 'claude[bot]'
          claude_args: |
            --allowedTools "WebFetch,WebSearch,Glob,Grep,Read,Task,TodoWrite,mcp__github__get_issue,mcp__github__get_issue_comments,mcp__github__add_issue_comment,mcp__github__update_issue"
          prompt: |
            You are creating comprehensive technical implementation plans with detailed task breakdowns following the GitHub spec-kit methodology.

            <context>
              <issue_details>${{ steps.setup.outputs.issue_details }}</issue_details>
              <issue_description>${{ steps.setup.outputs.issue_description }}</issue_description>
              <recent_comments>${{ steps.setup.outputs.recent_comments }}</recent_comments>
              <is_revision>${{ steps.setup.outputs.is_revision }}</is_revision>
              <last_human_user>${{ steps.setup.outputs.last_human_user }}</last_human_user>
            </context>

            ## Your Task
            ${{ steps.setup.outputs.is_revision == 'true' && '
            This is a REVISION based on previous feedback. Review the recent comments to understand what changes were requested and address them in your updated comprehensive plan.
            ' || '
            This is INITIAL COMPREHENSIVE PLANNING. Create both technical implementation plan AND detailed task breakdown based on the approved specifications.
            ' }}

            ## CRITICAL: Always Post Comment
            You MUST post a comment with your comprehensive plan. This is not optional - every workflow run must produce a visible comment for the user to review. Your plan will automatically be posted as a comment to the issue.

            ## Planning Process
            1. Use `mcp__github__get_issue_comments` to review all previous comments, especially the approved specifications
            2. Use Task tool with specialized agents for comprehensive codebase analysis:
               - Use Task with subagent_type: 'codebase-locator' to find relevant files and directories for the feature
               - Use Task with subagent_type: 'codebase-analyzer' to understand current implementation patterns and architecture
               - Use Task with subagent_type: 'codebase-pattern-finder' to find similar existing implementations to model after
               - Use Task with subagent_type: 'thoughts-locator' (if applicable) to find any existing documentation or plans related to this feature
               - Use Task with subagent_type: 'thoughts-analyzer' (if applicable) to extract insights from relevant historical decisions or research
            3. Validate technology choices against existing codebase patterns and constraints
            4. Define the technical approach and implementation strategy based on codebase analysis
            5. Consider integration points, dependencies, and potential challenges specific to this codebase
            6. Break down implementation into specific, actionable development tasks
            7. Create detailed technology stack and architecture plan with task-level breakdown

            ## Output Format
            Present your comprehensive plan as a structured document:

            ```
            # Technical Implementation Plan & Task Breakdown

            **Feature:** [Feature Name]
            **Issue:** #${{ github.event.issue.number }}
            **Date:** [Current Date]
            **Specification:** Link to approved specification in previous comments
            **Status:** Ready for Review

            ## What I'm Doing
            I've created a comprehensive technical implementation plan that combines high-level architecture decisions with detailed task breakdown. This plan defines both the HOW (technical approach, architecture, integration points) and the specific step-by-step tasks needed for implementation, building on the approved specifications.

            ## Technical Context & Research

            ### Current Technology Stack
            - **Language & Version:** [Programming language and version used in project]
            - **Framework:** [Current framework/platform]
            - **Dependencies:** [Key existing dependencies and versions]
            - **Database:** [Database technology if applicable]
            - **Testing Framework:** [Current testing tools and frameworks]
            - **Target Platform:** [Deployment platform/environment]

            ### Codebase Analysis
            [Results from codebase-locator, codebase-analyzer, and codebase-pattern-finder agents]
            - **Similar Patterns Found:** [Existing implementations to model after with file:line references]
            - **Integration Points:** [How new feature connects to existing code]
            - **Conventions to Follow:** [Project patterns and conventions discovered]

            ### Performance Goals
            - **Response Time:** [Expected performance metrics]
            - **Throughput:** [Capacity requirements]
            - **Resource Usage:** [Memory, CPU, storage constraints]

            ### Technical Constraints
            - **Compatibility:** [Version compatibility requirements]
            - **Security:** [Security compliance requirements]
            - **Integration:** [External system dependencies]

            ## Constitution Check

            ### Project Principles Alignment
            - [ ] **Simplicity:** Solution follows KISS principle and avoids over-engineering
            - [ ] **Architecture:** Maintains existing architectural patterns and consistency
            - [ ] **Testing:** Plan includes comprehensive testing strategy
            - [ ] **Observability:** Includes logging, monitoring, and debugging capabilities
            - [ ] **Documentation:** Technical decisions are well-documented

            ## Architecture Overview
            [High-level description of the technical approach and system architecture]

            ## Implementation Strategy

            ### Development Approach
            - **Pattern:** [Design patterns to be used]
            - **Structure:** [How code will be organized]
            - **Integration:** [How new code integrates with existing codebase]

            ### Key Components
            - **Component 1:** [Purpose, responsibilities, and interfaces]
            - **Component 2:** [Purpose, responsibilities, and interfaces]
            - **Component 3:** [Purpose, responsibilities, and interfaces]

            ### Data Flow & Storage
            - **Data Models:** [Key data structures and relationships]
            - **Storage Strategy:** [How data will be stored and accessed]
            - **Data Flow:** [How data moves through the system]

            ## Detailed Task Breakdown

            ### Setup & Foundation Phase
            **Sequential Tasks (must be completed in order):**

            - [ ] **T001**: [Specific setup task] - [File/component to create/modify]
              - **Type:** Setup | **Estimated Time:** [X hours] | **Dependencies:** None
              - **Acceptance:** [Specific measurable criteria]

            - [ ] **T002**: [Environment/config task] - [Configuration files to modify]
              - **Type:** Configuration | **Estimated Time:** [X hours] | **Dependencies:** T001
              - **Acceptance:** [Specific measurable criteria]

            ### Test-Driven Development Phase
            **TDD Approach - Write Tests First:**

            - [ ] **T003**: [Write unit tests for core component] - [Test files to create]
              - **Type:** Testing | **Estimated Time:** [X hours] | **Dependencies:** T002
              - **Acceptance:** [Test coverage and passing criteria]

            - [ ] **T004**: [Write integration tests] - [Test files to create]
              - **Type:** Testing | **Estimated Time:** [X hours] | **Dependencies:** T003
              - **Acceptance:** [Integration test success criteria]

            ### Core Implementation Phase
            **Parallel Tasks [P] can be worked on simultaneously:**

            - [ ] **T005** [P]: [Implement data model] - [Model files to create/modify]
              - **Type:** Data Layer | **Estimated Time:** [X hours] | **Dependencies:** T004
              - **Acceptance:** [Model validation and test passing criteria]

            - [ ] **T006** [P]: [Implement service layer] - [Service files to create/modify]
              - **Type:** Business Logic | **Estimated Time:** [X hours] | **Dependencies:** T004
              - **Acceptance:** [Service functionality and test passing criteria]

            - [ ] **T007**: [Implement API endpoints] - [Controller/route files to modify]
              - **Type:** API Layer | **Estimated Time:** [X hours] | **Dependencies:** T005, T006
              - **Acceptance:** [API response and functionality criteria]

            ### Integration & Features Phase

            - [ ] **T008**: [Integrate components] - [Integration files to modify]
              - **Type:** Integration | **Estimated Time:** [X hours] | **Dependencies:** T007
              - **Acceptance:** [End-to-end functionality criteria]

            - [ ] **T009** [P]: [Implement UI components] - [UI files to create/modify]
              - **Type:** Frontend | **Estimated Time:** [X hours] | **Dependencies:** T007
              - **Acceptance:** [UI functionality and design criteria]

            ### Validation & Polish Phase

            - [ ] **T010**: [Performance optimization] - [Files to optimize]
              - **Type:** Performance | **Estimated Time:** [X hours] | **Dependencies:** T008, T009
              - **Acceptance:** [Performance benchmark criteria]

            - [ ] **T011**: [Security validation] - [Security measures to implement]
              - **Type:** Security | **Estimated Time:** [X hours] | **Dependencies:** T008
              - **Acceptance:** [Security audit and test criteria]

            ## Dependency Graph
            ```
            T001 → T002 → T003 → T004 → [T005, T006] → T007 → T008 → T010
                                    ↓           ↓       ↓
                                   T009 ----→ T011 → [Complete]
            ```

            ## Task Rules Applied
            - ✅ **Modular**: Each task is independent and focused
            - ✅ **Testable**: Every implementation task has corresponding tests
            - ✅ **Sequential Logic**: Dependencies ensure proper build order
            - ✅ **Parallel Opportunities**: [P] tasks can be worked simultaneously
            - ✅ **Measurable**: Each task has specific acceptance criteria

            ## Files & Components Analysis

            ### New Files to Create:
            - [ ] `[path/to/test-file.spec.js]` - [Purpose and test coverage]
            - [ ] `[path/to/model-file.js]` - [Data model and validation]
            - [ ] `[path/to/service-file.js]` - [Business logic implementation]

            ### Existing Files to Modify:
            - [ ] `[path/to/existing-file.js]` - [Specific changes needed]
            - [ ] `[path/to/config-file.json]` - [Configuration updates]

            ## Testing Strategy
            - **Unit Testing:** [Approach for testing individual components]
            - **Integration Testing:** [Strategy for testing component interactions]
            - **End-to-End Testing:** [User workflow testing approach]
            - **Performance Testing:** [Load and performance validation]

            ## Risk Assessment & Mitigation
            - **Technical Risk 1:** [Description] → **Mitigation:** [Strategy]
            - **Technical Risk 2:** [Description] → **Mitigation:** [Strategy]
            - **Integration Risk:** [Description] → **Mitigation:** [Strategy]

            ## Dependencies & Prerequisites
            - [ ] **External Dependencies:** [Third-party services or APIs needed]
            - [ ] **Internal Dependencies:** [Other components or features required]
            - [ ] **Infrastructure:** [Server, database, or deployment requirements]
            - [ ] **Team Dependencies:** [Skills or resources needed]

            ## Complexity Tracking
            - **Overall Complexity:** [Low/Medium/High]
            - **Technical Debt Impact:** [Assessment of technical debt introduced]
            - **Maintenance Overhead:** [Long-term maintenance considerations]

            ## Review & Acceptance Checklist
            - [ ] Technical approach is sound and follows project patterns
            - [ ] All requirements from specification are addressed
            - [ ] Testing strategy is comprehensive
            - [ ] Security considerations are adequate
            - [ ] Performance requirements can be met
            - [ ] Dependencies are identified and manageable
            - [ ] Task breakdown is detailed and actionable
            - [ ] Each task has clear acceptance criteria
            - [ ] Dependencies between tasks are properly mapped

            **Next Steps:** Review this comprehensive plan and check the items you approve. Identify any concerns or needed adjustments. Then mention @claude-dev-truefrontier to proceed to development implementation.
            ```

            ## Required Actions (Execute in Order)

            **1. FIRST: Always Post Your Comprehensive Plan Comment Above**
            - You MUST explicitly call `mcp__github_comment__create_comment` or `mcp__github_comment__update_claude_comment` to post the complete plan with checkboxes as a comment
            - Include the formatted comprehensive plan document in the comment body
            - Do not proceed to step 2 until you have successfully posted the comment using the MCP tool

            **2. THEN: Update Workflow State**
            Only after successfully posting your comprehensive plan comment, execute these commands:

            Use `mcp__github__update_issue` with these parameters:
            - issue_number: ${{ github.event.issue.number }}
            - Remove "needs:plan" and "needs:plan-revision" from labels
            - Add "review:plan" to labels
            - Add assignee: "${{ steps.setup.outputs.last_human_user }}"

            First get current issue state with `mcp__github__get_issue`, then call `mcp__github__update_issue` with the updated labels list (keeping all non-workflow labels and adding review:plan).

            Focus on practical, implementable technical solutions that align with the project's existing architecture and constraints. Use codebase analysis agents to validate technology choices against existing patterns and discover similar implementations to model after. The specification stage will have already researched best practices and domain requirements - your job is to translate those into concrete technical implementation plans.