name: Stage - Plan & Tasks

on:
  issues:
    types: [labeled]

jobs:
  plan:
    if: >
      github.event.issue.state == 'open' &&
      (contains(github.event.issue.labels.*.name, 'needs:plan') ||
       contains(github.event.issue.labels.*.name, 'needs:plan-revision'))
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      actions: read
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup stage context
        id: setup
        uses: actions/github-script@v7
        with:
          script: |
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            // Get recent comments for context
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              per_page: 20
            });

            // Filter out deleted/empty comments and get non-bot comments
            const validComments = comments.data.filter(comment =>
              comment.body &&
              comment.body.trim() !== '' &&
              !comment.body.includes('[DELETED]')
            );

            // Check if this is initial plan or revision
            const labels = issue.labels.map(label => label.name);
            const isRevision = labels.includes('needs:plan-revision');

            // Find the last human who mentioned the bot (for assignment later)
            const lastHumanComment = validComments
              .reverse()
              .find(comment =>
                comment.user.type === 'User' &&
                comment.body.includes('@claude-dev-truefrontier')
              );

            const lastHumanUser = lastHumanComment ? lastHumanComment.user.login : null;
            core.setOutput('is_revision', isRevision.toString());
            core.setOutput('issue_details', JSON.stringify({
              ISSUE_NUMBER: context.issue.number,
              ASSIGNEES: issue.assignees || [],
              STATE: issue.state,
              CREATED_AT: issue.created_at,
              UPDATED_AT: issue.updated_at,
            }));
            core.setOutput('issue_description', issue.body || '');
            core.setOutput('recent_comments', JSON.stringify(validComments));
            core.setOutput('last_human_user', lastHumanUser);

      - name: Run Technical Planning
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          use_sticky_comment: true
          allowed_bots: 'claude[bot]'
          claude_args: |
            --allowedTools "WebFetch,WebSearch,Glob,Grep,Read,mcp__github_comment__create_comment,mcp__github_comment__update_claude_comment,mcp__github__get_issue_comments"
          prompt: |
            You are creating comprehensive technical implementation plans AND detailed task breakdowns following the GitHub spec-kit methodology.

            <context>
              <issue_details>${{ steps.setup.outputs.issue_details }}</issue_details>
              <issue_description>${{ steps.setup.outputs.issue_description }}</issue_description>
              <recent_comments>${{ steps.setup.outputs.recent_comments }}</recent_comments>
              <is_revision>${{ steps.setup.outputs.is_revision }}</is_revision>
              <last_human_user>${{ steps.setup.outputs.last_human_user }}</last_human_user>
            </context>

            ## Your Task
            ${{ steps.setup.outputs.is_revision == 'true' && '
            This is a REVISION based on previous feedback. Review the recent comments to understand what changes were requested and address them in your updated technical plan and task breakdown.
            ' || '
            This is INITIAL TECHNICAL PLANNING AND TASK BREAKDOWN. Create a comprehensive technical implementation plan AND detailed task breakdown based on the specifications provided.
            ' }}

            ## CRITICAL: Always Post Comment
            You MUST post a comment with your technical plan AND task breakdown. This is not optional - every workflow run must produce a visible comment for the user to review. Your combined plan and tasks will automatically be posted as a comment to the issue.

            ## Planning & Task Breakdown Process
            1. Use `mcp__github__get_issue_comments` to review all previous comments, especially the approved specifications
            2. Analyze the existing codebase architecture and patterns
            3. Research relevant technologies, frameworks, and libraries if needed
            4. Define the technical approach and implementation strategy
            5. Consider integration points, dependencies, and potential challenges
            6. Create a detailed technology stack and architecture plan
            7. Break down the implementation into specific, actionable development tasks
            8. Prioritize tasks and identify dependencies
            9. Create clear, numbered tasks with acceptance criteria

            ## Output Format
            Present your technical plan as a structured document:

            ```
            # Technical Implementation Plan & Task Breakdown

            **Feature:** [Feature Name]
            **Issue:** #${{ github.event.issue.number }}
            **Date:** [Current Date]
            **Specification:** Link to approved specification in previous comments
            **Status:** Ready for Review

            ## What I'm Doing
            I've created a comprehensive technical implementation plan AND detailed task breakdown based on the approved specifications. This combines the HOW (technology choices, architecture decisions, integration points) with the WHEN (specific numbered tasks, dependencies, and implementation order) - all building on the WHAT and WHY established in the specification phase.

            ## Technical Context

            ### Current Technology Stack
            - **Language & Version:** [Programming language and version used in project]
            - **Framework:** [Current framework/platform]
            - **Dependencies:** [Key existing dependencies and versions]
            - **Database:** [Database technology if applicable]
            - **Testing Framework:** [Current testing tools and frameworks]
            - **Target Platform:** [Deployment platform/environment]

            ### Performance Goals
            - **Response Time:** [Expected performance metrics]
            - **Throughput:** [Capacity requirements]
            - **Resource Usage:** [Memory, CPU, storage constraints]

            ### Technical Constraints
            - **Compatibility:** [Version compatibility requirements]
            - **Security:** [Security compliance requirements]
            - **Integration:** [External system dependencies]

            ## Constitution Check

            ### Project Principles Alignment
            - [ ] **Simplicity:** Solution follows KISS principle and avoids over-engineering
            - [ ] **Architecture:** Maintains existing architectural patterns and consistency
            - [ ] **Testing:** Plan includes comprehensive testing strategy
            - [ ] **Observability:** Includes logging, monitoring, and debugging capabilities
            - [ ] **Documentation:** Technical decisions are well-documented

            ## Architecture Overview
            [High-level description of the technical approach and system architecture]

            ## Implementation Strategy

            ### Development Approach
            - **Pattern:** [Design patterns to be used]
            - **Structure:** [How code will be organized]
            - **Integration:** [How new code integrates with existing codebase]

            ### Key Components
            - **Component 1:** [Purpose, responsibilities, and interfaces]
            - **Component 2:** [Purpose, responsibilities, and interfaces]
            - **Component 3:** [Purpose, responsibilities, and interfaces]

            ### Data Flow & Storage
            - **Data Models:** [Key data structures and relationships]
            - **Storage Strategy:** [How data will be stored and accessed]
            - **Data Flow:** [How data moves through the system]

            ## Phase Planning

            ### Phase 0: Research & Setup
            - [ ] Analyze existing codebase patterns
            - [ ] Identify reusable components
            - [ ] Set up development environment
            - [ ] Create feature branch structure

            ### Phase 1: Design & Contracts
            - [ ] Define component interfaces
            - [ ] Create data models and schemas
            - [ ] Design API contracts (if applicable)
            - [ ] Establish testing contracts

            ### Phase 2: Implementation Planning
            - [ ] Break down into specific tasks
            - [ ] Identify dependencies and blockers
            - [ ] Plan integration points
            - [ ] Define success criteria

            ## Testing Strategy
            - **Unit Testing:** [Approach for testing individual components]
            - **Integration Testing:** [Strategy for testing component interactions]
            - **End-to-End Testing:** [User workflow testing approach]
            - **Performance Testing:** [Load and performance validation]

            ## Risk Assessment & Mitigation
            - **Technical Risk 1:** [Description] → **Mitigation:** [Strategy]
            - **Technical Risk 2:** [Description] → **Mitigation:** [Strategy]
            - **Integration Risk:** [Description] → **Mitigation:** [Strategy]

            ## Dependencies & Prerequisites
            - [ ] **External Dependencies:** [Third-party services or APIs needed]
            - [ ] **Internal Dependencies:** [Other components or features required]
            - [ ] **Infrastructure:** [Server, database, or deployment requirements]
            - [ ] **Team Dependencies:** [Skills or resources needed]

            ## Complexity Tracking
            - **Overall Complexity:** [Low/Medium/High]
            - **Technical Debt Impact:** [Assessment of technical debt introduced]
            - **Maintenance Overhead:** [Long-term maintenance considerations]

            ## Review & Acceptance Checklist
            - [ ] Technical approach is sound and follows project patterns
            - [ ] All requirements from specification are addressed
            - [ ] Testing strategy is comprehensive
            - [ ] Security considerations are adequate
            - [ ] Performance requirements can be met
            - [ ] Dependencies are identified and manageable

            ---

            # Development Task Breakdown

            **Based on Technical Plan Above**
            **Issue:** #${{ github.event.issue.number }}
            **Date:** [Current Date]
            **Status:** Ready for Review

            ## Task Generation Summary
            Tasks derived from:
            - ✅ Approved specifications and requirements
            - ✅ Technical plan and architecture decisions (above)
            - ✅ Component contracts and interfaces
            - ✅ Data models and API design
            - ✅ User stories and acceptance criteria

            ## Implementation Tasks

            ### Setup & Foundation Phase
            **Sequential Tasks (must be completed in order):**

            - [ ] **T001**: [Specific setup task] - [File/component to create/modify]
              - **Type:** Setup | **Estimated Time:** [X hours] | **Dependencies:** None
              - **Acceptance:** [Specific measurable criteria]

            - [ ] **T002**: [Environment/config task] - [Configuration files to modify]
              - **Type:** Configuration | **Estimated Time:** [X hours] | **Dependencies:** T001
              - **Acceptance:** [Specific measurable criteria]

            ### Test-Driven Development Phase
            **TDD Approach - Write Tests First:**

            - [ ] **T003**: [Write unit tests for core component] - [Test files to create]
              - **Type:** Testing | **Estimated Time:** [X hours] | **Dependencies:** T002
              - **Acceptance:** [Test coverage and passing criteria]

            - [ ] **T004**: [Write integration tests] - [Test files to create]
              - **Type:** Testing | **Estimated Time:** [X hours] | **Dependencies:** T003
              - **Acceptance:** [Integration test success criteria]

            ### Core Implementation Phase
            **Parallel Tasks [P] can be worked on simultaneously:**

            - [ ] **T005** [P]: [Implement data model] - [Model files to create/modify]
              - **Type:** Data Layer | **Estimated Time:** [X hours] | **Dependencies:** T004
              - **Acceptance:** [Model validation and test passing criteria]

            - [ ] **T006** [P]: [Implement service layer] - [Service files to create/modify]
              - **Type:** Business Logic | **Estimated Time:** [X hours] | **Dependencies:** T004
              - **Acceptance:** [Service functionality and test passing criteria]

            - [ ] **T007**: [Implement API endpoints] - [Controller/route files to modify]
              - **Type:** API Layer | **Estimated Time:** [X hours] | **Dependencies:** T005, T006
              - **Acceptance:** [API response and functionality criteria]

            ### Integration & Features Phase

            - [ ] **T008**: [Integrate components] - [Integration files to modify]
              - **Type:** Integration | **Estimated Time:** [X hours] | **Dependencies:** T007
              - **Acceptance:** [End-to-end functionality criteria]

            - [ ] **T009** [P]: [Implement UI components] - [UI files to create/modify]
              - **Type:** Frontend | **Estimated Time:** [X hours] | **Dependencies:** T007
              - **Acceptance:** [UI functionality and design criteria]

            ### Validation & Polish Phase

            - [ ] **T010**: [Performance optimization] - [Files to optimize]
              - **Type:** Performance | **Estimated Time:** [X hours] | **Dependencies:** T008, T009
              - **Acceptance:** [Performance benchmark criteria]

            - [ ] **T011**: [Security validation] - [Security measures to implement]
              - **Type:** Security | **Estimated Time:** [X hours] | **Dependencies:** T008
              - **Acceptance:** [Security audit and test criteria]

            ## Dependency Graph
            ```
            T001 → T002 → T003 → T004 → [T005, T006] → T007 → T008 → T010
                                    ↓           ↓       ↓
                                   T009 ----→ T011 → [Complete]
            ```

            ## Task Rules Applied
            - ✅ **Modular**: Each task is independent and focused
            - ✅ **Testable**: Every implementation task has corresponding tests
            - ✅ **Sequential Logic**: Dependencies ensure proper build order
            - ✅ **Parallel Opportunities**: [P] tasks can be worked simultaneously
            - ✅ **Measurable**: Each task has specific acceptance criteria

            ## Files & Components Analysis

            ### New Files to Create:
            - [ ] `[path/to/test-file.spec.js]` - [Purpose and test coverage]
            - [ ] `[path/to/model-file.js]` - [Data model and validation]
            - [ ] `[path/to/service-file.js]` - [Business logic implementation]

            ### Existing Files to Modify:
            - [ ] `[path/to/existing-file.js]` - [Specific changes needed]
            - [ ] `[path/to/config-file.json]` - [Configuration updates]

            ## Risk Assessment & Mitigation
            - **High-Risk Tasks:** [T007, T008] - Complex integration points
              - **Mitigation:** Extra testing, incremental integration
            - **Medium-Risk Tasks:** [T005, T006] - Core business logic
              - **Mitigation:** TDD approach, thorough unit testing
            - **Parallel Risk:** [T005, T006, T009] - Potential merge conflicts
              - **Mitigation:** Clear interface contracts, frequent integration

            ## Success Criteria
            **Technical Completion:**
            - [ ] All numbered tasks completed successfully
            - [ ] All tests passing (unit, integration, end-to-end)
            - [ ] Code follows project conventions and standards
            - [ ] Performance benchmarks met
            - [ ] Security requirements satisfied

            **Business Completion:**
            - [ ] All specification requirements implemented
            - [ ] Acceptance criteria from user stories met
            - [ ] Feature ready for production deployment

            **Next Steps:** Review this combined technical plan and task breakdown. Check the items you approve and identify any concerns or needed adjustments. Then mention @claude-dev-truefrontier to proceed to development implementation.
            ```

            ## Required Actions (Execute in Order)

            **1. FIRST: Always Post Your Combined Technical Plan & Task Breakdown Comment Above**
            - You MUST explicitly call `mcp__github_comment__create_comment` or `mcp__github_comment__update_claude_comment` to post the complete technical plan AND task breakdown with checkboxes as a comment
            - Include the formatted combined document in the comment body
            - Do not proceed to step 2 until you have successfully posted the comment using the MCP tool

            **2. THEN: Update Workflow State**
            Only after successfully posting your combined technical plan and task breakdown comment, execute these commands:

            ```bash
            # Remove the current stage label
            gh issue edit ${{ github.event.issue.number }} \
              --remove-label "needs:plan" \
              --remove-label "needs:plan-revision"

            # Set to review state and assign to human
            gh issue edit ${{ github.event.issue.number }} \
              --add-label "review:plan" \
              --add-assignee "${{ steps.setup.outputs.last_human_user }}"
            ```

            Focus on practical, implementable technical solutions that align with the project's existing architecture and constraints. Use web research to validate technology choices and discover best practices. Create specific, actionable tasks that a developer can follow step-by-step to implement the technical plan.